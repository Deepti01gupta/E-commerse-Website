
project start process: 
npm init
npm i express nodemon ejs mongoose
npm start


http://localhost:8080/products


for database:
mongosh
show dbs
use shopping-sam-app
show collections
db.products.find()
db.reviews.deleteMany({});





TASK 1: basic server created and checked

TASK 2: DB to be connected (to let server and database interact with each other)

Jab bhi ham koi project banate hai to project k seperation of concern(soc) yaad rakhte hai
views : templets
public : static files
model : collections & schema (start the file name with capital letters)
shcema -> model -> DB (mogoose) -> require

export : jab hamne koi cheej ek file mai banai h or hame usse dusri file 
main use krna hai to usse export krte hai

TASK 3: Creating schema

TASK 4: Initial/Dummy data adding 
ek baar m bahut sara data db main add krne k liye " insertMany([]) " k use krte hai 
jo ek inputs ke array ko bhejte hai 
seed.js main ham apne initial data ko bhejte hai 
seed -> array -> inserting data
Db k sare methods(eg: insertmany, etc) promise return krte hai
seedDB(); = ye sirf ek baar chalana h initial data add krne k liye uske baad usko comment out kr denge

TASK 5: DB main se product show/display krne hai
get and post method is use 
hamara server express k hai to ham express ko require krenge
aap.js application ki instance hai isko ham export nahi kr skte
const router=express.Router(); // mini instance


populate is a technique.
dusri collections se render krate hai to populate use krte hai
product se review m data chahiye ye review m product se data chahiye
jab ek particular product ko show krenge tbhi uske sath reviews bhi show kr denge



time wali cheejo k sath kam krne ke liye hamare pass timestamp hota hai


Middleware in Express is a function that runs between the request and the response.
It can:
-> modify the request or response
-> run code before the route handler
-> stop the request (e.g., authentication, validation)
-> or pass it on to the next middleware/route
pre: mmiddleware chalne se phele
post: middleware chalne ke baad
findById and findByIdAndDelete behind k seen middleware ki use kr rha h
pre and post schema k middleware hai






Validation

Validation means checking whether the data is correct and acceptable.
It makes sure that whatever the user enters follows the rules you set in your schema or form.
There are two main types of validation:
1. Client-side validation → Done in the browser (front-end).
Example: If a field is marked as required, the browser won’t let the user submit until they fill it.
2. Server-side validation → Done on the backend (schema or server).
Example: In Mongoose, if you set { required: true } for a field, the server will reject saving the data if it’s missing.


required:
This is used to make sure the user must enter a value.
Example: If you mark name as required, the form won’t allow submission (client-side), and the server will also check (server-side) if the field is empty.

novalidate :
By default, the browser performs client-side validation on required fields.
If you add novalidate in the <form> tag, it turns off browser validation.
That means the user can submit the form even if required fields are empty — then only server-side validation will catch errors.



Joi:
Joi is one of the most powerful npm packages used for server-side validation.
It acts like a schema description language – meaning you first create a schema that defines the structure and rules for your data.
It validates incoming data (e.g., from forms or API requests) against that schema before saving it in the database.

Steps to use Joi -
1. Create a Schema: 
Define a Joi schema separately.
This schema contains the rules (like required, min, max, string, number, etc.)

2. Validate Data with the Schema:
Wherever you receive data (like in your route handler), you validate it using that schema.



Cookies: 
Client-side storage mechanism that stores data in key–value pairs.
Usage:
Personalization (e.g., remembering user preferences).
Session management (e.g., staying logged in).
Tracking user activity.

Nature:
Cookies are stored on the client (browser).
They are not very secure (can be read/modified by users).
To improve security, we can use signed cookies.

Packages: 
cookie-parser → Common middleware in Node.js for handling cookies.

Important Methods:
res.cookie() → Used to store a cookie in the client’s browser.
req.cookies → Used to read multiple cookies from the client request.

Sessions:
Server-side storage that keeps track of user data across requests in key value pair.
More secure than cookies, since data is not exposed directly to the client.
Typically, the client only stores a session ID cookie, while the actual data stays on the server.

Stateful vs Stateless:
Stateful → Depends on the previous state (e.g., sessions).
Stateless → Does not depend on previous state (e.g., simple API request without login).


flash(): 
flash messages (or simply "flash") are temporary messages that are stored on the server and shown to the user only once, usually after a redirect.
Key Points about Flash Messages:
They are short-lived → exist for a single request–response cycle.

Commonly used for:
Success messages (✅ "Your product was added!")
Error messages (❌ "Invalid email or password.")
Informational alerts (ℹ️ "You have been logged out.")

Implemented in Node.js apps using packages like connect-flash or sometimes with session middleware.


locals :
locals are local variables that can be accessed directly inside your views (like EJS, Pug, Handlebars).
Instead of passing the same variable manually in every res.render(), you can define it once and use it everywhere.

Types of Locals:
1. res.locals:
Scoped to a single response.
Variables are available only for that request–response cycle.

2. app.locals:
Scoped to the entire application.
Available in all views for the lifetime of the app.

Why use Locals:
-> To avoid repeating variables in every res.render().
-> For global data like app name, user info, year, etc.
-> Helps in consistent rendering across multiple views.







https://www.passportjs.org/packages/passport-local/
Authentication & Authorization with Passport.js
1. Authentication vs Authorization:
Authentication → Verifying who the user is (login/signup).
Authorization → Deciding what the authenticated user is allowed to do (permissions, roles, access levels).

2. Password Handling:
Never store passwords directly in the database.
Instead:
Hash the password (convert it into an irreversible fixed-length string).
Add salt (a random value) to protect against rainbow table attacks.
Store only the hash + salt, not the raw password.

3. Hashing vs Encryption:
Hashing → One-way process (cannot get back original input).
Encryption → Two-way process (can decrypt back to original input).
Example:
SHA (Secure Hash Algorithm) is a hashing function.
If an algorithm allows you to retrieve the original password from the output, then it’s not hashing, it’s encryption.

4. Passport.js:
Passport → Authentication middleware for Node.js.
Provides different strategies (ways to authenticate).

5. Strategies:
passport-local
A strategy to authenticate using username/email + password.
passport-local-mongoose
Mongoose plugin that integrates with passport-local.
Handles password hashing, salting, and authentication automatically.
You only store username and email; plugin adds fields for hash and salt.

6. Flow of User Signup/Login:
User enters username + password.
Password is hashed + salted before being stored in DB.
During login, entered password is hashed again.

7. Logout:
To log out, you call req.logout() inside a callback function.
This removes req.user from the session.

This means:
Login → req.user is added.
Logout → req.user is removed.



Hash is compared with stored hash → if match → authentication success.
static methods: static method vo method hote hai jo directly apke schema ke upar lag jaye
1. authenticate(): Generates a function that is used in Passport's LocalStrategy
2. serializeUser(): Generates a function that is used by Passport to serialize users into the session
3. deserializeUser(): Generates a function that is used by Passport to deserialize users into the session
4. register(user, password, cb): Convenience method to register a new user instance with a given password. Checks if username is unique. See login example.
5. findByUsername(): Convenience method to find a user instance by it's unique username.
6. createStrategy(): Creates a configured passport-local LocalStrategy instance that can be used in passport.


sam : 123, seller
bob : 123, buyer
tom : 123, seller
max : 123


2 object id ko compare krenge to == ye === nahi denge uske liye function use krenge "equals" wala


ADD TO CART:
